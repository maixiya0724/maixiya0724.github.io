<!DOCTYPE html>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
  
  <title>ts教程 - 毛西亚的博客</title>
  <meta charset="UTF-8">
  <meta name="description" content="记录生活的所见所闻">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png">
  <meta name="description" content="TypeScript 教程 蒹葭苍苍，白露未霜，所谓伊人，在水一方.">
<meta name="keywords" content="技术">
<meta property="og:type" content="article">
<meta property="og:title" content="ts教程">
<meta property="og:url" content="http://yoursite.com/2019/07/28/技术/前端/ts教程/index.html">
<meta property="og:site_name" content="毛西亚的博客">
<meta property="og:description" content="TypeScript 教程 蒹葭苍苍，白露未霜，所谓伊人，在水一方.">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-12-06T08:03:12.854Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ts教程">
<meta name="twitter:description" content="TypeScript 教程 蒹葭苍苍，白露未霜，所谓伊人，在水一方.">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/css/mdui.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.15.8/styles/atom-one-dark.css">
   
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" href="//at.alicdn.com/t/font_1505827_k6fd86fxksp.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1038733_0xvrvpg9c0r.css ">
  <link rel="stylesheet" href="/css/style.css?v=1591347993303">
</head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(https://i.loli.net/2019/01/13/5c3aec85a4343.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">menu</i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="毛西亚" class="mdui-btn mdui-btn-icon"><img src="https://iconfont.alicdn.com/t/1573548190528.jpeg@100h_100w.jpg"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="毛西亚">
            <img src="https://iconfont.alicdn.com/t/1573548190528.jpeg@100h_100w.jpg" alt="毛西亚">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>15</div>
        <div><span>标签</span>6</div>
        <div><span>分类</span>4</div>
    </div>
    <ul class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
    </ul>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">社交按钮</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com/20238211" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/hexo/">hexo</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/忆/">忆</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/技术/">技术</a>
          <span class="category-list-count">12</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/搬砖/">搬砖</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">标签云</h3>
    <div id="randomtagcloud" class="nexmoe-widget tagcloud">
      <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/忆/" style="font-size: 10px;">忆</a> <a href="/tags/技术/" style="font-size: 20px;">技术</a> <a href="/tags/搬砖/" style="font-size: 10px;">搬砖</a>
    </div>
    
  </div>

  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2020 毛西亚
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://nexmoe.com/hexo-theme-nexmoe.html" target="_blank">Nexmoe</a>
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <div class="nexmoe-post">
    <div class="nexmoe-post-cover"> 
        
            <img src="https://i.loli.net/2019/01/13/5c3aec85a4343.jpg">
        
        <h1>ts教程</h1>
    </div>
  <div class="nexmoe-post-meta">
    <a><i class="nexmoefont icon-calendar-fill"></i>2019年07月28日</a>
    <a><i class="nexmoefont icon-areachart"></i>7.1k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 32 分钟</a>
    
      <a class="nexmoefont icon-appstore-fill -link" href="/categories/技术/">技术</a>
    
    
      <a class="nexmoefont icon-tag-fill -link" href="/tags/技术/">技术</a>
    
  </div>
  <article>
    <h1 id="TypeScript-教程"><a href="#TypeScript-教程" class="headerlink" title="TypeScript 教程"></a>TypeScript 教程</h1><blockquote>
<p>蒹葭苍苍，白露未霜，所谓伊人，在水一方.</p>
</blockquote>
<a id="more"></a>

<h3 id="之前一直都想要找时间把ts的只是给巩固一下-，找个时间抽离一下"><a href="#之前一直都想要找时间把ts的只是给巩固一下-，找个时间抽离一下" class="headerlink" title="之前一直都想要找时间把ts的只是给巩固一下 ，找个时间抽离一下"></a>之前一直都想要找时间把ts的只是给巩固一下 ，找个时间抽离一下</h3><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><pre><code>npm install -g typescript</code></pre><p>安装完成以后在node 命令行里面 通过 tsc dome.ts 命令 可以把 ts编译为js</p>
<ol>
<li>开发工具如何自动编译 ts文件  </li>
</ol>
<ul>
<li>vscode<br>安装完成以后 在ts终端里面运行 tsc –init  生成typescript.config.js 的配置文件 然后修改里面的输出目录  outDir  指定输入的js目录来进行</li>
</ul>
<ol start="2">
<li>在终端里面 运行任务 选择监视ts 然后可以边修改ts文件边编译成js 是不是很方便呢</li>
</ol>
<h2 id="2-TS-的数据类型"><a href="#2-TS-的数据类型" class="headerlink" title="2. TS 的数据类型"></a>2. TS 的数据类型</h2><p>ts中定义类型的时候会增加类型校验 在声明的时候必须指定类型</p>
<pre><code>string 类型
var a:string =  &apos;rerer&apos;
number 类型 
var b:number = 24343
boolean 类型
var c:boolean = true
Array 类型 
第一种
var d:number[] = [1,2,3] // 定义里面的元数据都是number类型
第二种
var e:Array&lt;number&gt;= [11,22]</code></pre><ul>
<li>枚举类型</li>
</ul>
<ul>
<li>任意类型 </li>
</ul>
<pre><code>//变量没有制定类型的话，默认是定义为任意类型
let a:any = 14
a =&apos;43434&apos; // 不会报错
// ts会在没有明确的指定类型的时候推测出一个类型，这就是类型推论 定义变量的时候赋值了,该变量的类型就是赋值的类型，如果只定义未赋值，改变量就会被推断成any类型，而不会被类型检查
let str = &apos;12323&apos;
str = 12323 // 报错 str通过类型推断为string类型

let str2;
str2 = &apos;3232&apos;
str2 = 1232 // 不报错  如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查</code></pre><ul>
<li><p>联合类型<br>  联合类型表示取值可以为多种类型中的一种<br>  联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型</p>
<pre><code>var str:string | number  = &apos;1232&apos;
str = 12323 
// 既可以为string 也可以为number</code></pre></li>
<li><p>underfined 类型  </p>
<pre><code>var num:underfined 
console.log(num)</code></pre></li>
<li><p>null 类型</p>
<pre><code>var num:null 
var num:null | number | underfined 可以是 null number underfined</code></pre></li>
<li><p>void<br>ts 中的void 表示没有任何类型 一般用于定义方法的时候没有返回值</p>
<pre><code>js定义方法 没有返回值
function fn(){
    console.log(14232)
}

ts为了严谨 定义没有返回值的方法时用void类型 表示方法没有任何类型
function fn():void{
    console.log(11)
}
如果有返回值的话就声明返回的类型
function fn():string{
    console.log(11)
}</code></pre></li>
<li><p>never 类型 是其他类型的子类型包括 null和undefined代表从不会出现的值 这意味着never 类型只能被never类型赋值</p>
</li>
</ul>
<h2 id="3-变量声明"><a href="#3-变量声明" class="headerlink" title="3.变量声明"></a>3.变量声明</h2><h4 id="ts的变量声明方式和js的变量声明方式一样，有var-let-const-等三种方式"><a href="#ts的变量声明方式和js的变量声明方式一样，有var-let-const-等三种方式" class="headerlink" title="ts的变量声明方式和js的变量声明方式一样，有var let const 等三种方式"></a>ts的变量声明方式和js的变量声明方式一样，有var let const 等三种方式</h4><h2 id="4-接口"><a href="#4-接口" class="headerlink" title="4.接口"></a>4.接口</h2><h4 id="在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。"><a href="#在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。" class="headerlink" title="在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。"></a>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。</h4><pre><code>//定义一个接口
interface Person{
    name:string,
    age:number,
    job?:string, // 可选属性 不是必须拥有的属性
    readonly reayRead:number, // 只读属性，表明该属性只能在创建的时候修改值，以后不能修改
    propName : any,  // 任意类型
    [propName: string]:any // 可扩展其他值，可增加任意个属性
}</code></pre><h4 id="ts-接口注意一点"><a href="#ts-接口注意一点" class="headerlink" title="ts 接口注意一点"></a>ts 接口注意一点</h4><pre><code>interface TargetInfo{
    name?:string;
    info:{x:number,y:number};
    [propName: string]: number;
}</code></pre><p>注意这样写会报错，可扩展参数一样约束了可选参数的类型，name为string，而可扩展参数为number，这是不允许的</p>
<h4 id="接口就是对类的形状的描述，接口可以用来对类型的属性进行命名-对属性的检查"><a href="#接口就是对类的形状的描述，接口可以用来对类型的属性进行命名-对属性的检查" class="headerlink" title="接口就是对类的形状的描述，接口可以用来对类型的属性进行命名,对属性的检查"></a>接口就是对类的形状的描述，接口可以用来对类型的属性进行命名,对属性的检查</h4><h2 id="5-类"><a href="#5-类" class="headerlink" title="5.类"></a>5.类</h2><p>####传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本</p>
<pre><code>class Animal {
    public name: string; // 公共属性 默认为public
    private obj :string;  // 私有属性 当成员被标记为private的时候 他就不能在声明他的类的外部访问 例如 new Animal(&quot;Cat&quot;).name 报错
    readonly age:number; // 只读属性 只读属性必须在声明时或构造函数里被初始化
}</code></pre><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6.函数"></a>6.函数</h2><h4 id="和JavaScript一样，TypeScript函数可以创建有名字的函数和匿名函数。-你可以随意选择适合应用程序的方式，不论是定义一系列API函数还是只使用一次的函数。"><a href="#和JavaScript一样，TypeScript函数可以创建有名字的函数和匿名函数。-你可以随意选择适合应用程序的方式，不论是定义一系列API函数还是只使用一次的函数。" class="headerlink" title="和JavaScript一样，TypeScript函数可以创建有名字的函数和匿名函数。 你可以随意选择适合应用程序的方式，不论是定义一系列API函数还是只使用一次的函数。"></a>和JavaScript一样，TypeScript函数可以创建有名字的函数和匿名函数。 你可以随意选择适合应用程序的方式，不论是定义一系列API函数还是只使用一次的函数。</h4><pre><code>// 匿名函数
let add = function(x,y){
    return x+y
}
//命名函数 
function add(x,y){
    return x+y
}</code></pre><h4 id="6-1函数类型"><a href="#6-1函数类型" class="headerlink" title="6.1函数类型"></a>6.1函数类型</h4><p>我们可以为函数添加类型</p>
<pre><code>function add(x:number,y:number):number{ // 该函数为number类型
    return x+y
}

// 函数表达式
let add = function(x:number,y:number):number{
    return x+y
}

// 上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 add，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 add 添加类型，则应该是这样：

let add:(x:number,y:number)=&gt; number = function(x:number,y:number):number{
    return x+y
}</code></pre><ul>
<li>与接口中的可选属性类似，我们用 ? 表示可选的参数</li>
</ul>
<pre><code>// 可选参数 可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必需参数了

function anyParam(x:string,y?:string):string{
    return x+&apos;/&apos;+y
}</code></pre><ul>
<li>参数默认值<br>  在 ES6 中，我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数</li>
</ul>
<pre><code>function fnMo(x:string = &apos;tom&apos;,y?:any=&apos;12323&apos;):any{
    return x+y
}</code></pre><h2 id="7-定义数组"><a href="#7-定义数组" class="headerlink" title="7.定义数组"></a>7.定义数组</h2><ul>
<li><p>类型 + 方括号」表示法</p>
<pre><code>let arr:number[] = [1,2,3,4,5] //定义一个number数组 里面的元素只能是number

let arr2 :any[] = [1,&apos;2&apos;,undefined,{}] // 任意元素的数组</code></pre></li>
<li><p>数组泛型 </p>
<pre><code>let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];</code></pre></li>
</ul>
<h2 id="8-类型断言"><a href="#8-类型断言" class="headerlink" title="8.类型断言"></a>8.类型断言</h2><pre><code>类型断言可以用来手动指定一个值的类型 </code></pre><ul>
<li>语法 </li>
</ul>
<pre><code>    &lt;类型&gt;值 
或

    值 as 类型</code></pre><p>在 tsx 语法（React 的 jsx 语法的 ts 版）中必须用后一种</p>
<h4 id="将一个联合类型的变量指定为一个更加具体的类型"><a href="#将一个联合类型的变量指定为一个更加具体的类型" class="headerlink" title="将一个联合类型的变量指定为一个更加具体的类型"></a>将一个联合类型的变量指定为一个更加具体的类型</h4><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：</p>
<pre><code>function getLength(something: string | number): number {
    return something.length;
}

// index.ts(2,22): error TS2339: Property &apos;length&apos; does not exist on type &apos;string | number&apos;.
//   Property &apos;length&apos; does not exist on type &apos;number&apos;.</code></pre><p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，比如：</p>
<pre><code>function getLength(something: string | number): number {
    if (something.length) {
        return something.length;
    } else {
        return something.toString().length;
    }
}

// index.ts(2,19): error TS2339: Property &apos;length&apos; does not exist on type &apos;string | number&apos;.
//   Property &apos;length&apos; does not exist on type &apos;number&apos;.
// index.ts(3,26): error TS2339: Property &apos;length&apos; does not exist on type &apos;string | number&apos;.
// </code></pre><p>上例中，获取 something.length 的时候会报错。<br>此时可以使用类型断言，将 something 断言成 string：</p>
<pre><code>function toBoolean(something: string | number): boolean {
    return &lt;boolean&gt;something;
}

// index.ts(2,10): error TS2352: Type &apos;string | number&apos; cannot be converted to type &apos;boolean&apos;.
//   Type &apos;number&apos; is not comparable to type &apos;boolean&apos;. </code></pre><h3 id="9-声明文件"><a href="#9-声明文件" class="headerlink" title="9.声明文件"></a>9.声明文件</h3><p>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</p>
<h4 id="9-1-新语法索引"><a href="#9-1-新语法索引" class="headerlink" title="9.1 新语法索引"></a>9.1 新语法索引</h4><p>由于本章涉及大量新语法，故在本章开头列出新语法的索引，方便大家在使用这些新语法时能快速查找到对应的讲解：</p>
<ul>
<li><code>declare var</code> 声明全局变量</li>
<li><code>declare function</code> 声明全局方法</li>
<li><code>declare class</code> 声明全局类</li>
<li><code>declare enum</code>声明全局枚举类型</li>
<li><code>declare namespace</code> 声明（含有子属性的）全局对象</li>
<li><code>interface</code> 和 <code>type</code> 声明全局类型</li>
<li><code>export</code> 导出变量</li>
<li><code>export namespace</code> 导出（含有子属性的）对象</li>
<li><code>export default</code> ES6 默认导出</li>
<li><code>export = commonjs</code> 导出模块</li>
<li><code>export as namespace</code> UMD 库声明全局变量</li>
<li><code>declare global</code> 扩展全局变量</li>
<li><code>declare module</code> 扩展模块</li>
<li><code>/// &lt;reference /&gt;</code> 三斜线指令</li>
</ul>
<h4 id="9-1-1-什么是声明语句"><a href="#9-1-1-什么是声明语句" class="headerlink" title="9.1.1 什么是声明语句"></a>9.1.1 什么是声明语句</h4><p>当我们想使用第三方库 比如jquery的时候 一种常见的方式是通过script标签引入 然后用 <code>$</code>或<code>jquery</code>来进行操作</p>
<p>例如 </p>
<pre><code>$(&apos;#box&apos;)
//or 
jQuery(&quot;#box&quot;)</code></pre><p>但是在ts中，编辑器并不知道 <code>$</code>或者<code>jQuery</code>是什么东西</p>
<pre><code>$(&quot;#jquery&quot;) 
// ERROR: Cannot find name &apos;jQuery&apos;.</code></pre><p>这时候我们需要使用 <code>declare var</code> 来定义他的类型</p>
<pre><code>declare var jQuery: (selector: string) =&gt; any;

jQuery(&apos;#foo&apos;);</code></pre><p>上例中，declare var 并没有真的定义一个变量，只是定义了全局变量 jQuery 的类型，仅仅会用于编译时的检查，在编译结果中会被删除。它编译结果是：</p>
<pre><code>jQuery(&apos;#foo&apos;);</code></pre><p>除了 declare var 之外，还有其他很多种声明语句</p>
<h4 id="9-1-2-什么是声明文件"><a href="#9-1-2-什么是声明文件" class="headerlink" title="9.1.2 什么是声明文件"></a>9.1.2 什么是声明文件</h4><p>通常我们会把声明语句放到一个单独的文件（jQuery.d.ts）中，这就是声明文件</p>
<pre><code>在这个文件里面声明所有的声明语句

// src/jQuery.d.ts
declare var jQuery: (selector: string) =&gt; any;

// src/index.ts
jQuery(&apos;#foo&apos;);</code></pre><p>声明文件必需以 .d.ts 为后缀。</p>
<p>一般来说，ts 会解析项目中所有的 *.ts 文件，当然也包含以 .d.ts 结尾的文件。所以当我们将 jQuery.d.ts 放到项目中时，其他所有 *.ts 文件就都可以获得 jQuery 的类型定义了。而且 其他文件不需要引入这个文件</p>
<pre><code>/path/to/project
├── src
|  ├── index.ts
|  └── jQuery.d.ts
└── tsconfig.json</code></pre><p>假如仍然无法解析，那么可以检查下 tsconfig.json 中的 files、include 和 exclude 配置，确保其包含了 jQuery.d.ts 文件。<br>这里只演示了全局变量这种模式的声明文件，假如是通过模块导入的方式使用第三方库的话，那么引入声明文件又是另一种方式了，将会在后面详细介绍。</p>
<h4 id="9-1-3-第三方声明文件"><a href="#9-1-3-第三方声明文件" class="headerlink" title="9.1.3 第三方声明文件"></a>9.1.3 第三方声明文件</h4><p>当然，jQuery 的声明文件不需要我们定义了，社区已经帮我们定义好了：jQuery in DefinitelyTyped。<br>我们可以直接下载下来使用，但是更推荐的是使用 @types 统一管理第三方库的声明文件。<br>@types 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例</p>
<pre><code>npm install @types/jquery --save-dev</code></pre><p>可以在<a href="https://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">这个页面</a>搜索你需要的声明文件</p>
<h4 id="9-1-4-书写声明文件"><a href="#9-1-4-书写声明文件" class="headerlink" title="9.1.4 书写声明文件"></a>9.1.4 书写声明文件</h4><p>当一个第三方库没有提供声明文件时，我们就需要自己书写声明文件了。前面只介绍了最简单的声明文件内容，而真正书写一个声明文件并不是一件简单的事，以下会详细介绍如何书写声明文件。<br>在不同的场景下，声明文件的内容和使用方式会有所区别。</p>
<p>库的使用场景主要有以下几种：</p>
<ul>
<li>全局变量：通过 <code>&lt;script&gt;</code>标签引入第三方库，注入全局变量</li>
<li>npm 包：通过 import foo from ‘foo’ 导入，符合 ES6 模块规范</li>
<li>UMD 库：既可以通过 <code>&lt;script&gt;</code> 标签引入，又可以通过 import 导入</li>
<li>直接扩展全局变量：通过 <code>&lt;script&gt;</code> 标签引入后，改变一个全局变量的结构</li>
<li>在 npm 包或 UMD 库中扩展全局变量：引用 npm 包或 UMD 库后，改变一个全局变量的结构</li>
<li>模块插件：通过 <code>&lt;script&gt;</code> 或 import 导入后，改变另一个模块的结构</li>
</ul>
<h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><p> 全局变量是最简单的一种场景，之前举的例子就是通过 <code>&lt;script&gt;</code> 标签引入 <code>jQuery</code>，注入全局变量 $ 和 <code>jQuery</code>。<br>使用全局变量的声明文件时，如果是以 <code>npm install @types/xxx --save-dev</code> 安装的，则不需要任何配置。如果是将声明文件直接存放于当前项目中，则建议和其他源码一起放到 src 目录下（或者对应的源码目录下）   </p>
<pre><code>/path/to/project
├── src
|  ├── index.ts
|  └── jQuery.d.ts
└── tsconfig.json</code></pre><p>如果没有生效，可以检查下 <code>tsconfig.json</code> 中的 <code>files、include</code> 和 <code>exclude</code> 配置，确保其包含了 <code>jQuery.d.ts</code> 文件。</p>
<ul>
<li><code>declare var</code> 声明全局变量</li>
<li><code>declare function</code> 声明全局方法</li>
<li><code>declare class</code> 声明全局类</li>
<li><code>declare enum</code> 声明全局枚举类型</li>
<li><code>declare namespace</code> 声明（含有子属性的）全局对象</li>
<li><code>interface</code> 和 <code>type</code> 声明全局类型</li>
</ul>
<h4 id="declare-var"><a href="#declare-var" class="headerlink" title="declare var"></a><code>declare var</code></h4><p>在所有的声明语句中，declare var 是最简单的，如之前所学，它能够用来定义一个全局变量的类型。与其类似的，还有 declare let 和 declare const，使用 let 与使用 var 没有什么区别：</p>
<pre><code>// src/index.ts
jQuery(&apos;#foo&apos;)
// 使用declare let 定义的jQuery 类型，允许修改这个全局变量
jQuery = function(selector) {
    return document.querySelector(selector);
};</code></pre><p>而当我们使用 const 定义时，表示此时的全局变量是一个常量，不允许再去修改它的值了</p>
<p>一般来说，全局变量都是禁止修改的常量，所以大部分情况都应该使用 const 而不是 var 或 let。</p>
<p>需要注意的是，声明语句中只能定义类型，切勿在声明语句中定义具体的实现</p>
<h4 id="declare-function"><a href="#declare-function" class="headerlink" title="declare function"></a><code>declare function</code></h4><p><code>declare function</code> 用来定义全局函数的类型。jquery就是一个函数所以也可以用function来定义 </p>
<pre><code>declare function jQuery(selector:string):any;

jQuery(&apos;#foo&apos;)</code></pre><h4 id="declare-class"><a href="#declare-class" class="headerlink" title="declare class"></a><code>declare class</code></h4><p>当全局变量是一个类的时候，我们用 declare class 来定义它的类型</p>
<pre><code>// src/Animal.d.ts
declare class Animal {
    name: string;
    constructor(name: string);
    sayHi(): string;
}</code></pre><p>同样的，declare class 语句也只能用来定义类型，不能用来定义具体的实现，比如定义 sayHi 方法的具体实现则会报错：</p>
<pre><code>// src/Animal.d.ts
declare class Animal {
    name: string;
    constructor(name: string);
    sayHi() {
        return `My name is ${this.name}`;
    };
    // ERROR: An implementation cannot be declared in ambient contexts.
}</code></pre><h4 id="declare-enum"><a href="#declare-enum" class="headerlink" title="declare enum"></a><code>declare enum</code></h4><p>使用 declare enum 定义的枚举类型也称作外部枚举（Ambient Enums），举例如下</p>
<pre><code>// src/Directions.d.ts
declare enum Directions {
    Up,
    Down,
    Left,
    Right
}

// src/index.ts
let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</code></pre><p>与其他全局变量的类型声明一致，declare enum 仅用来定义类型，而不是具体的值。<br>Directions.d.ts 仅仅会用于编译时的检查，声明文件里的内容在编译结果中会被删除。它编译结果是：</p>
<pre><code>var directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</code></pre><p>其中 Directions 是由第三方库定义好的全局变量</p>
<h4 id="declare-namespace"><a href="#declare-namespace" class="headerlink" title="declare namespace"></a><code>declare namespace</code></h4><p><code>namespace</code> 是 ts 早期时为了解决模块化而创造的关键字，中文称为命名空间。<br>由于历史遗留原因，在早期还没有 ES6 的时候，ts 提供了一种模块化方案，使用 module 关键字表示内部模块。但由于后来 ES6 也使用了 <code>module</code> 关键字，ts 为了兼容 ES6，使用 <code>namespace</code> 替代了自己的 <code>module</code>，更名为命名空间。<br>随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的 <code>namespace</code>，而推荐使用 ES6 的模块化方案了，故我们不再需要学习 <code>namespace</code> 的使用了。<br>n<code>amespace</code> 被淘汰了，但是在声明文件中，<code>declare namespace</code> 还是比较常用的，它用来表示全局变量是一个对象，包含很多子属性。<br>比如 jQuery 是一个全局变量，它是一个对象，提供了一个 <code>jQuery.ajax</code> 方法可以调用，那么我们就应该使用 <code>declare namespace jQuery</code> 来声明这个拥有多个子属性的全局变量。</p>
<pre><code>// src/jQuery.d.ts
declare namespace jQuery {
    function ajax(url: string, settings?: any): void;
}</code></pre><p>注意，在 declare namespace 内部，我们直接使用 function ajax 来声明函数，而不是使用 declare function ajax。类似的，也可以使用 const, class, enum 等语句9</p>
<pre><code>// src/jQuery.d.ts

declare namespace jQuery {
    function ajax(url: string, settings?: any): void;
    const version: number;
    class Event {
        blur(eventType: EventType): void
    }
    enum EventType {
        CustomClick
    }
}


// src/index.ts

jQuery.ajax(&apos;/api/get_something&apos;);
console.log(jQuery.version);
const e = new jQuery.Event();
e.blur(jQuery.EventType.CustomClick);</code></pre><h4 id="npm-包"><a href="#npm-包" class="headerlink" title="npm 包"></a>npm 包</h4><p>一般我们通过 <code>import foo from &#39;foo&#39;</code> 导入一个 npm 包，这是符合 ES6 模块规范的.<br>在我们尝试给一个 npm 包创建声明文件之前，需要先看看它的声明文件是否已经存在。一般来说，npm 包的声明文件可能存在于两个地方：</p>
<h5 id="1-与该-npm-包绑定在一起。判断依据是-package-json-中有-types-字段，或者有一个-index-d-ts-声明文件。这种模式不需要额外安装其他包，是最为推荐的，所以以后我们自己创建-npm-包的时候，最好也将声明文件与-npm-包绑定在一起。"><a href="#1-与该-npm-包绑定在一起。判断依据是-package-json-中有-types-字段，或者有一个-index-d-ts-声明文件。这种模式不需要额外安装其他包，是最为推荐的，所以以后我们自己创建-npm-包的时候，最好也将声明文件与-npm-包绑定在一起。" class="headerlink" title="1.与该 npm 包绑定在一起。判断依据是 package.json 中有 types 字段，或者有一个 index.d.ts 声明文件。这种模式不需要额外安装其他包，是最为推荐的，所以以后我们自己创建 npm 包的时候，最好也将声明文件与 npm 包绑定在一起。"></a>1.与该 npm 包绑定在一起。判断依据是 <code>package.json</code> 中有 types 字段，或者有一个 <code>index.d.ts</code> 声明文件。这种模式不需要额外安装其他包，是最为推荐的，所以以后我们自己创建 npm 包的时候，最好也将声明文件与 npm 包绑定在一起。</h5><h5 id="2-发布到-types-里。我们只需要尝试安装一下对应的-types-包就知道是否存在该声明文件，安装命令是-npm-install-types-foo-save-dev。这种模式一般是由于-npm-包的维护者没有提供声明文件，所以只能由其他人将声明文件发布到-types-里了。"><a href="#2-发布到-types-里。我们只需要尝试安装一下对应的-types-包就知道是否存在该声明文件，安装命令是-npm-install-types-foo-save-dev。这种模式一般是由于-npm-包的维护者没有提供声明文件，所以只能由其他人将声明文件发布到-types-里了。" class="headerlink" title="2.发布到 @types 里。我们只需要尝试安装一下对应的 @types 包就知道是否存在该声明文件，安装命令是 npm install @types/foo --save-dev。这种模式一般是由于 npm 包的维护者没有提供声明文件，所以只能由其他人将声明文件发布到 @types 里了。"></a>2.发布到 @types 里。我们只需要尝试安装一下对应的 @types 包就知道是否存在该声明文件，安装命令是 <code>npm install @types/foo --save-dev</code>。这种模式一般是由于 npm 包的维护者没有提供声明文件，所以只能由其他人将声明文件发布到 @types 里了。</h5><p>假如以上两种方式都没有找到对应的声明文件，那么我们就需要自己为它写声明文件了。由于是通过 import 语句导入的模块，所以声明文件存放的位置也有所约束，一般有两种方案：</p>
<h5 id="1-创建一个-node-modules-types-foo-index-d-ts-文件，存放-foo-模块的声明文件。这种方式不需要额外的配置，但是-node-modules-目录不稳定，代码也没有被保存到仓库中，无法回溯版本，有不小心被删除的风险，故不太建议用这种方案，一般只用作临时测试。"><a href="#1-创建一个-node-modules-types-foo-index-d-ts-文件，存放-foo-模块的声明文件。这种方式不需要额外的配置，但是-node-modules-目录不稳定，代码也没有被保存到仓库中，无法回溯版本，有不小心被删除的风险，故不太建议用这种方案，一般只用作临时测试。" class="headerlink" title="1.创建一个 node_modules/@types/foo/index.d.ts 文件，存放 foo 模块的声明文件。这种方式不需要额外的配置，但是 node_modules 目录不稳定，代码也没有被保存到仓库中，无法回溯版本，有不小心被删除的风险，故不太建议用这种方案，一般只用作临时测试。"></a>1.创建一个 <code>node_modules/@types/foo/index.d.ts</code> 文件，存放 foo 模块的声明文件。这种方式不需要额外的配置，但是 <code>node_modules</code> 目录不稳定，代码也没有被保存到仓库中，无法回溯版本，有不小心被删除的风险，故不太建议用这种方案，一般只用作临时测试。</h5><h5 id="2-创建一个-types-目录，专门用来管理自己写的声明文件，将-foo-的声明文件放到-types-foo-index-d-ts-中。这种方式需要配置下-tsconfig-json-中的-paths-和-baseUrl-字段。"><a href="#2-创建一个-types-目录，专门用来管理自己写的声明文件，将-foo-的声明文件放到-types-foo-index-d-ts-中。这种方式需要配置下-tsconfig-json-中的-paths-和-baseUrl-字段。" class="headerlink" title="2.创建一个 types 目录，专门用来管理自己写的声明文件，将 foo 的声明文件放到 types/foo/index.d.ts 中。这种方式需要配置下 tsconfig.json 中的 paths 和 baseUrl 字段。"></a>2.创建一个 types 目录，专门用来管理自己写的声明文件，将 foo 的声明文件放到 <code>types/foo/index.d.ts</code> 中。这种方式需要配置下 <code>tsconfig.json</code> 中的 paths 和 baseUrl 字段。</h5><p>目录结构</p>
<pre><code>/path/to/project
├── src
|  └── index.ts
├── types
|  └── foo
|     └── index.d.ts
└── tsconfig.json</code></pre><p><code>tsconfig.json</code> 内容：</p>
<pre><code>{
    &quot;compilerOptions&quot;: {
        &quot;module&quot;: &quot;commonjs&quot;,
        &quot;baseUrl&quot;: &quot;./&quot;,
        &quot;paths&quot;: {
            &quot;*&quot;: [&quot;types/*&quot;]
        }
    }
}</code></pre><p>如此配置之后，通过 import 导入 foo 的时候，也会去 types 目录下寻找对应的模块的声明文件了。</p>
<p>注意 module 配置可以有很多种选项，不同的选项会影响模块的导入导出模式。这里我们使用了 commonjs 这个最常用的选项，后面的教程也都默认使用的这个选项。<br>不管采用了以上两种方式中的哪一种，我都强烈建议大家将书写好的声明文件（通过给第三方库发 pull request，或者直接提交到 @types 里）发布到开源社区中，享受了这么多社区的优秀的资源，就应该在力所能及的时候给出一些回馈。只有所有人都参与进来，才能让 ts 社区更加繁荣。</p>
<p>npm 包的声明文件主要有以下几种语法</p>
<ul>
<li><code>export</code> 导出变量</li>
<li><code>export namespace</code> 导出(含有子属性的)对象</li>
<li><code>export defalut</code> ES6 默认导出</li>
<li><code>export =</code> commonjs导出模块</li>
</ul>
<h3 id="待完善"><a href="#待完善" class="headerlink" title="待完善"></a>待完善</h3><h3 id="10-内置对象"><a href="#10-内置对象" class="headerlink" title="10.内置对象"></a>10.内置对象</h3><p>JavaScript 中有很多内置对象，它们可以直接在 <code>TypeScript</code> 中当做定义好了的类型。</p>
<p>内置对象是指根据标准在全局作用域<code>（Global）</code>上存在的对象。这里的标准是指 <code>ECMAScript</code> 和其他环境（比如 DOM）的标准。</p>
<h4 id="10-1-ECMAScript-的内置对象"><a href="#10-1-ECMAScript-的内置对象" class="headerlink" title="10.1 ECMAScript 的内置对象"></a>10.1 ECMAScript 的内置对象</h4><p>ECMAScript 标准提供的内置对象有<br><code>Boolean</code>、<code>Error</code>、<code>Date</code>、<code>RegExp</code> 等。<br>我们可以在 TypeScript 中将变量定义为这些类型：</p>
<pre><code>let b: Boolean = new Boolean(1);
let e: Error = new Error(&apos;Error occurred&apos;);
let d: Date = new Date();
let r: RegExp = /[a-z]/;</code></pre><p>更多的内置对象，可以查看 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">MDN 的文档</a>。</p>
<h4 id="10-2-DOM-和-BOM-的内置对象"><a href="#10-2-DOM-和-BOM-的内置对象" class="headerlink" title="10.2 DOM 和 BOM 的内置对象"></a>10.2 DOM 和 BOM 的内置对象</h4><p>DOM 和 BOM 提供的内置对象有：<br><code>Document</code>, <code>HTMLElement</code>,<code>Event</code>,<code>NodeList</code> 等</p>
<p>TypeScript 中会经常用到这些类型</p>
<pre><code>let body: HTMLElement = document.body;
let allDiv: NodeList = document.querySelectorAll(&apos;div&apos;);
document.addEventListener(&apos;click&apos;, function(e: MouseEvent) {
// Do something
});</code></pre><p>它们的定义文件同样在 <a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib" target="_blank" rel="noopener">TypeScript 核心库的定义文件</a>中。</p>
<h4 id="10-3-TypeScript-核心库的定义文件"><a href="#10-3-TypeScript-核心库的定义文件" class="headerlink" title="10.3 TypeScript 核心库的定义文件"></a>10.3 TypeScript 核心库的定义文件</h4><p><a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib" target="_blank" rel="noopener">TypeScript 核心库的定义文件</a>中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。</p>
<p>当你在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了，比如：</p>
<pre><code>Math.pow(10, &apos;2&apos;);
// index.ts(1,14): error TS2345: Argument of type &apos;string&apos; is not assignable to parameter of type &apos;number&apos;.</code></pre><p>上面的例子中，<code>Math.pow</code> 必须接受两个 <code>number</code> 类型的参数。事实上 <code>Math.pow</code> 的类型定义如下：</p>
<pre><code>interface Math {
/**
    * Returns the value of a base expression taken to a specified power.
    * @param x The base value of the expression.
    * @param y The exponent value of the expression.
    */
    pow(x: number, y: number): number;
}</code></pre><p>再举一个 DOM 中的例子：</p>
<pre><code>document.addEventListener(&apos;click&apos;, function(e) {
    console.log(e.targetCurrent);
});

// index.ts(2,17): error TS2339: Property &apos;targetCurrent&apos; does not exist on type &apos;MouseEvent&apos;.</code></pre><p>上面的例子中，<code>addEventListener</code> 方法是在 TypeScript 核心库中定义的：</p>
<pre><code>interface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent {
    addEventListener(type: string, listener: (ev: MouseEvent) =&gt; any, useCapture?: boolean): void;
}</code></pre><p>所以 e 被推断成了 MouseEvent，而 MouseEvent 是没有 targetCurrent 属性的，所以报错了。<br>注意，TypeScript 核心库的定义中不包含 Node.js 部分。</p>
<h3 id="11-用-TypeScript-写-Node-js"><a href="#11-用-TypeScript-写-Node-js" class="headerlink" title="11.用 TypeScript 写 Node.js"></a>11.用 TypeScript 写 Node.js</h3><p>Node.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：</p>
<pre><code>npm install @types/node --save-dev</code></pre><h3 id="12-元组"><a href="#12-元组" class="headerlink" title="12.元组"></a>12.元组</h3><p>数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。<br>元组起源于函数编程语言（如 F#），这些语言中会频繁使用元组。</p>
<p>元组和数组的 区别</p>
<pre><code>// 声明数组
let arr:any [] = [1,&apos;i love you&apos;,{name:&apos;1232&apos;}]

// 声明元组
let tom:[string,number] = [&apos;name&apos;,25]</code></pre><p>元组和数组有一定的相似，数组的方法元组也有 元组可以指定某一个元素的类型，可以是any的数组，但是any数组无法控制某一个确定下标元素的类型。</p>
<p>当赋值或访问一个已知索引的元素时，会得到正确的类型：</p>
<pre><code>let tom: [string, number];
tom[0] = &apos;Tom&apos;;
tom[1] = 25;

tom[0].slice(1);
tom[1].toFixed(2);</code></pre><p>也可以只赋值其中一项：</p>
<pre><code>let tom: [string, number];
tom[0] = &apos;Tom&apos;;</code></pre><h3 id="13-枚举"><a href="#13-枚举" class="headerlink" title="13.枚举"></a>13.枚举</h3><p>枚举(enum)类型用于取值被限定在一定范围内的场景,比如一周只能有七天,颜色限定为红绿蓝等.</p>
<h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><pre><code>//定义一个枚举
enum Days {sun,mon,tue,wed,thu,fri,sat};</code></pre><p>枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射：</p>
<pre><code>enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};

console.log(Days[&quot;Sun&quot;] === 0); // true
console.log(Days[&quot;Mon&quot;] === 1); // true
console.log(Days[&quot;Tue&quot;] === 2); // true
console.log(Days[&quot;Sat&quot;] === 6); // true

console.log(Days[0] === &quot;Sun&quot;); // true
console.log(Days[1] === &quot;Mon&quot;); // true
console.log(Days[2] === &quot;Tue&quot;); // true
console.log(Days[6] === &quot;Sat&quot;); // true</code></pre><p>事实上，上面的例子会被编译为：</p>
<pre><code>var Days;
(function (Days) {
    Days[Days[&quot;Sun&quot;] = 0] = &quot;Sun&quot;;
    Days[Days[&quot;Mon&quot;] = 1] = &quot;Mon&quot;;
    Days[Days[&quot;Tue&quot;] = 2] = &quot;Tue&quot;;
    Days[Days[&quot;Wed&quot;] = 3] = &quot;Wed&quot;;
    Days[Days[&quot;Thu&quot;] = 4] = &quot;Thu&quot;;
    Days[Days[&quot;Fri&quot;] = 5] = &quot;Fri&quot;;
    Days[Days[&quot;Sat&quot;] = 6] = &quot;Sat&quot;;
})(Days || (Days = {}));</code></pre><h4 id="手动赋值"><a href="#手动赋值" class="headerlink" title="手动赋值"></a>手动赋值</h4><p>我们也可以给枚举项手动赋值：</p>
<pre><code>enum Days {Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat};

console.log(Days[&quot;Sun&quot;] === 7); // true
console.log(Days[&quot;Mon&quot;] === 1); // true
console.log(Days[&quot;Tue&quot;] === 2); // true
console.log(Days[&quot;Sat&quot;] === 6); // true</code></pre><p>上面的例子中,未手动复制的枚举项会接着上一个枚举递增</p>
<h4 id="常数项和计算所得项"><a href="#常数项和计算所得项" class="headerlink" title="常数项和计算所得项"></a>常数项和计算所得项</h4><p>枚举项有两种类型：常数项（constant member）和计算所得项（computed member）。<br>前面我们所举的例子都是常数项，一个典型的计算所得项的例子：</p>
<pre><code>enum Color {Red,Green,Blue = &quot;blue343&quot;.length}

console.log(Color[&quot;Blue&quot;]) // 7</code></pre><p>上面的例子不会报错，但是如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错：</p>
<pre><code>enum Color {Red = &quot;red&quot;.length, Green, Blue};

// index.ts(1,33): error TS1061: Enum member must have initializer.
// index.ts(1,40): error TS1061: Enum member must have initializer.</code></pre><h4 id="常数枚举"><a href="#常数枚举" class="headerlink" title="常数枚举"></a>常数枚举</h4><p>常数枚举是使用 <code>const enum</code> 定义的枚举类型</p>
<pre><code>const enum Directions {
    Up,
    Down,
    Left,
    Right
}

let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</code></pre><p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。</p>
<h4 id="外部枚举"><a href="#外部枚举" class="headerlink" title="外部枚举"></a>外部枚举</h4><p>外部枚举是使用<code>declare enum</code> 定义的枚举类型</p>
<pre><code>declare enum Directions {
    Up,
    Down,
    Left,
    Right
}

let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];



之前提到过，declare 定义的类型只会用于编译时的检查，编译结果中会被删除。

上例的编译结果是：

var directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]</code></pre><h3 id="14-类"><a href="#14-类" class="headerlink" title="14.类"></a>14.类</h3><p>传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承。而在 ES6 中，我们终于迎来了 class传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承。而在 ES6 中，我们终于迎来了 class</p>
<h4 id="typescript-中的类的用法"><a href="#typescript-中的类的用法" class="headerlink" title="typescript 中的类的用法"></a>typescript 中的类的用法</h4><h4 id="14-1-publish-private-和-protected"><a href="#14-1-publish-private-和-protected" class="headerlink" title="14.1 publish private 和 protected"></a>14.1 publish private 和 protected</h4><p>TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 <code>public</code>、<code>private</code> 和 <code>protected</code>。</p>
<ul>
<li><p><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是</p>
</li>
<li><p><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</p>
</li>
<li><p><code>protected</code> 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的</p>
</li>
</ul>
<p>下面举一些例子：</p>
<pre><code>class Animal{
    public name;// 公共变量可以在外部获取
    public constructor(name){
        this.name = name
    }
}

let a = new Animal(&apos;Jack&apos;);
console.log(a.name); // Jack
a.name = &apos;Tom&apos;;
console.log(a.name); // Tom</code></pre><p>上面的例子中，name 被设置为了 public，所以直接访问实例的 name 属性是允许的。很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 private 了：</p>
<pre><code>class Animal {
    private name;// 私有变量，无法在外部获取并且在通过extends来继承的子类也是无法获取的
    public constructor(name) {
        this.name = name;
    }
}

let a = new Animal(&apos;Jack&apos;);
console.log(a.name); // Jack
a.name = &apos;Tom&apos;;

// index.ts(9,13): error TS2341: Property &apos;name&apos; is private and only accessible within class &apos;Animal&apos;.
// index.ts(10,1): error TS2341: Property &apos;name&apos; is private and only accessible within class &apos;Animal&apos;.</code></pre><p>而如果是用 protected 修饰，则允许在子类中访问：</p>
<pre><code>class Animal {
    protected name;
    public constructor(name) {
        this.name = name;
    }
}

class Cat extends Animal {
    constructor(name) {
        super(name);
        console.log(this.name);
    }
}</code></pre><p>当构造函数修饰为 private 时，该类不允许被继承或者实例化：</p>
<pre><code>class Animal {
    public name;
    private constructor (name) {
        this.name = name;
}
}
class Cat extends Animal {
    constructor (name) {
        super(name);
    }
}

let a = new Animal(&apos;Jack&apos;);

// index.ts(7,19): TS2675: Cannot extend a class &apos;Animal&apos;. Class constructor is marked as private.
// index.ts(13,9): TS2673: Constructor of class &apos;Animal&apos; is private and only accessible within the class declaration.</code></pre><p>当构造函数修饰为 protected 时，该类只允许被继承：</p>
<pre><code>class Animal {
    public name;
    protected constructor (name) {
        this.name = name;
}
}
class Cat extends Animal {
    constructor (name) {
        super(name);
    }
}

let a = new Animal(&apos;Jack&apos;);

// index.ts(13,9): TS2674: Constructor of class &apos;Animal&apos; is protected and only accessible within the class declaration.</code></pre><p>修饰符还可以使用在构造函数参数中，等同于类中定义该属性，使代码更简洁。</p>
<pre><code>class Animal {
    // public name: string;
    public constructor (public name) {
        this.name = name;
    }
}</code></pre><h3 id="类的类型"><a href="#类的类型" class="headerlink" title="类的类型"></a>类的类型</h3><p>给类加上 TypeScript 的类型很简单，与接口类似：</p>
<pre><code>class Animal {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
    sayHi(): string {
    return `My name is ${this.name}`;
    }
}

let a: Animal = new Animal(&apos;Jack&apos;);
console.log(a.sayHi()); // My name is Jack</code></pre><h3 id="14-类与接口"><a href="#14-类与接口" class="headerlink" title="14.类与接口"></a>14.类与接口</h3><p>接口可以用于对对象形状的描述，接口也可以有另外一个用途就是对类的一部分行为进行抽象</p>

  </article>
  
    
<div class="nexmoe-post-copyright">
<i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
<strong>本文作者：</strong>毛西亚<br>
<strong>本文链接：</strong><a href="http://yoursite.com/2019/07/28/技术/前端/ts教程/" title="http://yoursite.com/2019/07/28/技术/前端/ts教程/" target="_blank" rel="noopener">http://yoursite.com/2019/07/28/技术/前端/ts教程/</a><br>

  <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可

</div>


  
  <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
</section>
</div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/js/mdui.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
 
    <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


 
    <script src="https://cdn.jsdelivr.net/npm/smoothscroll-for-websites@1.4.9/SmoothScroll.min.js"></script>


<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="/js/app.js?v=1591347993314"></script>
<script src="https://cdn.jsdelivr.net/npm/lazysizes@5.1.0/lazysizes.min.js"></script>


    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>



  





</body>

</html>
